# MCP 服务器配置调试之旅总结

本次调试的目标是解决 Claude Code 插件无法连接到名为 `Martin-mcp-kit` 的本地 MCP 服务器的问题。整个过程一波三折，涉及了从环境配置、命令语法到工具链行为的多个层面。

## 最终的工作配置

这是我们最终确定的、能够正常工作的 `.mcp.json` 文件内容：

```json
{
  "mcpServers": {
    "Martin-mcp-kit": {
      "type": "stdio",
      "command": "wsl",
      "args": [
        "-d",
        "Ubuntu-22.04",
        "-e",
        "bash",
        "-c",
        "source /home/martin/.nvm/nvm.sh && cd /home/martin/my-project/mcpserver && node ./build/index.js"
      ]
    }
  }
}
```

## 调试步骤与踩坑记录

1.  **初步诊断 (插件配置)**：我们最开始检查了 `.claude/plugins/config.json`，发现它为空。虽然这不是导致连接失败的直接原因，但它揭示了插件加载可能存在的问题。
    -   **踩坑点**：容易被次要问题干扰，而忽略了主要的连接问题。

2.  **定位到 MCP 配置**：我们转向了 `.mcp.json`，发现了硬编码的 Linux 路径，并开始怀疑路径的正确性。

3.  **环境检查 (Node.js)**：通过 `wsl -e which node` 检查 `node` 是否存在，命令失败，让我们一度认为 Node.js 未安装。
    -   **踩坑点**：这是本次调试最关键的转折点——**非交互式 Shell 的环境问题**。

4.  **交互式 vs. 非交互式 Shell**：您在 WSL 中手动执行 `which node` 成功，证明了 Node.js 已通过 `nvm` 安装。这揭示了：VS Code 或 `wsl -e` 启动的**非交互式 Shell** 不会加载 `.bashrc` 等配置文件，因此 `nvm` 设置的环境变量（如 `PATH`）无效。

5.  **尝试修复 `PATH` 问题**：
    -   **方案A (绝对路径)**：我们尝试使用 `node` 的绝对路径 (`/home/martin/.../bin/node`)。这解决了“找不到 node”的问题，但连接依然失败。
    -   **方案B (pnpm start)**：根据 `README`，我们切换到 `pnpm start`。但这引入了“俄罗斯套娃”问题：`pnpm` 本身能被找到，但它再去寻找 `node` 时又失败了。

6.  **发现配置优先级问题**：我们注意到，无论怎么修改项目中的 `.mcp.json`，`claude mcp list` 显示的命令都不变。通过回查日志，发现 `claude mcp add` 命令修改的是**全局配置文件** (`C:\Users\xwbcl\.claude.json`)，并且它的优先级高于项目配置。
    -   **踩坑点**：不了解工具的配置优先级（全局 vs. 项目），导致所有本地修改都无效。

7.  **解决配置覆盖**：通过手动编辑，您删除了全局配置中的冲突项，这使得 Claude Code 终于开始读取我们项目中的 `.mcp.json` 文件。

8.  **最终的 Bug (`sh` vs `bash`)**：在确认所有配置都正确后，手动运行最终命令，发现了 `sh: 1: source: not found` 错误。
    -   **踩坑点**：`sh` 不等于 `bash`。`sh` 通常是一个更基础的 POSIX shell（在 Ubuntu 中是 `dash`），它不包含 `bash` 的一些特性，比如 `source` 命令（`sh` 中对应的命令是 `.`）。将 `sh -c` 更换为 `bash -c` 最终解决了问题。

## 主要收获与经验教训

1.  **环境是关键**：永远要警惕**非交互式 Shell** 和**交互式 Shell** 的环境差异。自动化工具、IDE 插件、CI/CD 脚本等通常在非交互式环境中运行，它们拥有一个“最小化”的环境，不会加载 `.bashrc` 或 `.zshrc`。
2.  **命令要明确**：在脚本或配置中，要么使用**绝对路径**来调用程序，要么确保在执行前**显式地加载环境**（如 `source ~/.nvm/nvm.sh`）。
3.  **理解配置层级**：当遇到配置不生效的问题时，要检查是否存在更高优先级的配置文件（如全局配置 vs. 项目配置 vs. 用户配置）。
4.  **Shell 的细微差别**：不要想当然地认为 `sh` 就是 `bash`。为了确保脚本的兼容性和功能的完整性，特别是在需要 `source` 等特定功能时，明确使用 `bash -c "..."` 是更安全的选择。
5.  **调试 `stdio` 服务**：对于通过标准输入输出 (stdio) 通信的服务，当 IDE 只提示“连接失败”时，最佳调试方法是**将启动命令复制出来，在终端中手动运行**，以查看最原始的错误输出。

这次调试之旅充分展现了从应用层问题，一步步深入到环境配置、工具链行为，最终定位到基础 Shell 差异的完整过程。非常有价值！
